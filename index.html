<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>...</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

let scene, camera, renderer;
let corridorSegments = [];
const SEGMENT_LENGTH = 40;
const SEGMENT_COUNT = 12;
let speed = 0.05;
let time = 0;

init();
animate();

function init() {
  scene = new THREE.Scene();
  scene.fog = new THREE.Fog(0x111111, 10, 180);

  camera = new THREE.PerspectiveCamera(
    60,
    window.innerWidth / window.innerHeight,
    0.1,
    500
  );
  camera.position.set(0, 1.6, 5);

  renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setClearColor(0x111111);
  document.body.appendChild(renderer.domElement);

  // Ambient hum light
  scene.add(new THREE.AmbientLight(0x404040, 0.6));

  // Build initial corridor
  for (let i = 0; i < SEGMENT_COUNT; i++) {
    const segment = createSegment(-i * SEGMENT_LENGTH);
    corridorSegments.push(segment);
    scene.add(segment.group);
  }

  window.addEventListener("resize", onResize);
}

function createSegment(zPos) {
  const group = new THREE.Group();
  group.position.z = zPos;

  const wallMat = new THREE.MeshStandardMaterial({
    color: 0xd6d1b0,
    roughness: 0.9,
  });

  const floorMat = new THREE.MeshStandardMaterial({
    color: 0xcfc8a5,
    roughness: 1.0,
  });

  const ceilingMat = new THREE.MeshStandardMaterial({
    color: 0xe0dcc0,
    roughness: 0.8,
  });

  // Floor
  const floor = new THREE.Mesh(
    new THREE.BoxGeometry(10, 0.1, SEGMENT_LENGTH),
    floorMat
  );
  floor.position.y = 0;
  group.add(floor);

  // Ceiling
  const ceiling = new THREE.Mesh(
    new THREE.BoxGeometry(10, 0.1, SEGMENT_LENGTH),
    ceilingMat
  );
  ceiling.position.y = 3;
  group.add(ceiling);

  // Walls
  const wallGeo = new THREE.BoxGeometry(0.1, 3, SEGMENT_LENGTH);

  const leftWall = new THREE.Mesh(wallGeo, wallMat);
  leftWall.position.set(-5, 1.5, 0);
  group.add(leftWall);

  const rightWall = new THREE.Mesh(wallGeo, wallMat);
  rightWall.position.set(5, 1.5, 0);
  group.add(rightWall);

  // Fluorescent light
  const light = new THREE.PointLight(0xffffee, 0.8, 18);
  light.position.set(0, 2.8, 0);
  group.add(light);

  return { group, light };
}

function animate() {
  requestAnimationFrame(animate);
  time += 0.01;

  // Move corridor forward endlessly
  corridorSegments.forEach((seg) => {
    seg.group.position.z += speed;

    // Subtle flicker
    seg.light.intensity =
      0.6 + Math.sin(time * 3 + seg.group.position.z) * 0.1;

    // Recycle segment
    if (seg.group.position.z > SEGMENT_LENGTH) {
      seg.group.position.z -= SEGMENT_LENGTH * SEGMENT_COUNT;
    }
  });

  // Camera drift (liminal float)
  camera.position.x = Math.sin(time * 0.3) * 0.2;
  camera.position.y = 1.6 + Math.sin(time * 0.2) * 0.1;

  renderer.render(scene, camera);
}

function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>
</body>
</html>
